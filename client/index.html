<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src 'self' http://localhost:8080; script-src 'self' 'unsafe-inline' 'unsafe-eval' http://localhost:8080; style-src 'self' 'unsafe-inline' http://localhost:8080;">


<style>
html,body {
  margin: 0px;
  padding: 0px;
  overflow: none;
  background-color: #000;
  font-family: Monospace;
}
canvas {
  margin: 0px;
  padding: 0px;
  width: 100%; height: 100%;
  position: absolute;
  left: 0px;
  top: 0px;
}

#log {
  position: absolute;
  top: 0px; right: 0px;
  margin: 0px;
  padding: 10px;
  color: #fff;
  background-color: hsla(50, 0%, 10%, .75);
  z-index: 1000;
}

</style>
<body>
<div id="container"></div>
<canvas id="webgl-canvas"></canvas>
<div id="log">log</div>

<script src="js/gl-matrix-min.js"></script>  
<script src="js/screenfull.js"></script>  
<script src="js/utils.js"></script> 
<script src="js/math_utils.js"></script>
<script src="js/socket.js"></script> 
<script src="js/webutils.js"></script> 
<script src="js/three-r102/build/three.js"></script>
<script src="js/three-r102/examples/js/vr/WebVR.js"></script>

<script>
let canvas = document.getElementById("webgl-canvas");
let log = document.getElementById("log");

let sock
try {
    if (window.location.hostname == "localhost") {
        sock = new Socket({
            reload_on_disconnect: true,
            reconnect_period: 1000,
            onopen: function() {
                //this.send({ cmd: "getdata", date: Date.now() });
            },
            onmessage: function(msg) { 
                console.log("received", msg);
            },
            onbuffer(data, byteLength) {
                console.log ("received binary:", byteLength);
            },
        });
    }
} catch (e) {
	console.error(e);
}

</script>
<script>
let patch = {
  "nodes": {
    "a": {
      "_props": { "kind": "noise", "pos": [ 0.0, 1.5, 0.0 ] },
      "signal": { "_props": { "kind": "outlet" } }
    },
    "b": {
      "_props": { "kind": "dac", "pos": [ 0.0, 1.0, 0.0 ] },
      "source": { "_props": { "kind": "inlet" } }
    },
    "child": {
      "_props": { "kind": "group", "pos": [ 0.5, 1.5, 0.0 ] },
      "aa": {
        "_props": {  "kind": "beep", "pos": [ 0.0, 0.2, 0.0 ] },
        "signal":  { "_props": { "kind": "outlet" } }
      }
    },
    "x": { "_props": {  "kind": "noise", "pos": [ -0.5, 1.5, 0.0] } }
  },
  "arcs": [
    [  "a.signal", "b.source" ],
    [ "child.a.signal", "b" ]
  ]
}
</script>
<script>
var container;
var camera, scene, renderer;
var controller1, controller2;
var raycaster,
    intersected = [];
let tempMatrix = new THREE.Matrix4();
let group;

let splineHelperObjects = [];
let splinePointsLength = 4;
let positions = [new THREE.Vector3(0.7, 0.5, 0.1),
        new THREE.Vector3(-0.5, 0.4, -0.09),
        new THREE.Vector3(-0.4, 0.4, -0.9),
        new THREE.Vector3(-0.7, 0.1, 0.8)
    ];
let point = new THREE.Vector3();
let geometry = new THREE.BoxBufferGeometry(0.2, 0.2, 0.2);
let geometry2 = new THREE.BoxBufferGeometry(0.1, 0.1, 0.1);
let ARC_SEGMENTS = 40;
let splines = {};
let params = {
    uniform: true,
    tension: 0.5,
    centripetal: true,
    chordal: true
};




init();
animate();

function init() {
    //container = document.getElementById('container');
    //document.body.appendChild(container);
    // let info = document.createElement("div");
    // container.appendChild(info);
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x20ff80);
    camera = new THREE.PerspectiveCamera(
        70,
        window.innerWidth / window.innerHeight,
        0.1,
        10
    );

    renderer = new THREE.WebGLRenderer({
        antialias: true,
        canvas: canvas
    });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.gammaInput = true;
    renderer.gammaOutput = true;
    renderer.shadowMap.enabled = true;
    renderer.vr.enabled = true;
    //container.appendChild(renderer.domElement);
    document.body.appendChild(WEBVR.createButton(renderer));
    // controllers
    controller1 = renderer.vr.getController(0);
    controller1.addEventListener("selectstart", onSelectStart);
    controller1.addEventListener("selectend", onSelectEnd);
    scene.add(controller1);
    controller2 = renderer.vr.getController(1);
    controller2.addEventListener("selectstart", onSelectStart);
    controller2.addEventListener("selectend", onSelectEnd);
    scene.add(controller2);


    scene.add(new THREE.HemisphereLight(0x808080, 0x606060));
    scene.background = new THREE.Color(0xf0f0f0);
    let light = new THREE.DirectionalLight(0xffffff);
    light.position.set(0, 6, 0);
    light.castShadow = true;
    light.shadow.camera.top = 2;
    light.shadow.camera.bottom = -2;
    light.shadow.camera.right = 2;
    light.shadow.camera.left = -2;
    light.shadow.mapSize.set(4096, 4096);
    scene.add(light);
    group = new THREE.Group();
    scene.add(group);
    let geometries = [
        new THREE.BoxBufferGeometry(0.5, 0.5, 0.5),
        // new THREE.ConeBufferGeometry(0.2, 0.2, 64),
        // new THREE.CylinderBufferGeometry(0.2, 0.2, 0.2, 64),
        // new THREE.IcosahedronBufferGeometry(0.2, 3),
        // new THREE.TorusBufferGeometry(0.2, 0.04, 64, 32)
    ];
  
    for (let i = 0; i < 2; i++) {
        let geometry = geometries[Math.floor(Math.random() * geometries.length)];
        let material = new THREE.MeshStandardMaterial({
            color: Math.random() * 0xffffff,
            roughness: 0.7,
            metalness: 0.0
        });
        let object = new THREE.Mesh(geometry, material);
        object.position.x = Math.random() * 4 - 2;
        object.position.y = Math.random() * 2;
        object.position.z = Math.random() * 4 - 2;
        object.rotation.x = Math.random() * 2 * Math.PI;
        object.rotation.y = Math.random() * 2 * Math.PI;
        object.rotation.z = Math.random() * 2 * Math.PI;
        object.scale.setScalar(Math.random() + 0.5);
        object.castShadow = true;
        object.receiveShadow = true;
        group.add(object);
    }

    let geometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, -1)
    ]);
    let line = new THREE.Line(geometry);
    line.name = "line";
    line.scale.z = 1;
    controller1.add(line.clone());
    controller2.add(line.clone());
    raycaster = new THREE.Raycaster();
    window.addEventListener("resize", onWindowResize, false);


    let helper = new THREE.GridHelper(10, 10);
    helper.position.y = 0;
    helper.material.opacity = 0.25;
    helper.material.transparent = true;
    scene.add(helper);

    /**********
     * Curves *
     **********/
  
    for (let i = 0; i < splinePointsLength; i++) {
        addSplineObject(positions[i], i);
    }
    // positions = [];
  
    // for (let i = 0; i < splinePointsLength; i++) {
    //     positions.push(splineHelperObjects[i].position);
    // }
  
    //Three patch cord connection lines (red, green, blue) 
    let patchCord = new THREE.BufferGeometry(20, 20, 20);
    patchCord.addAttribute('position', new THREE.BufferAttribute(new Float32Array(ARC_SEGMENTS * 3), 3));
    let curve = new THREE.CatmullRomCurve3(positions);
    curve.curveType = 'catmullrom';
    curve.mesh = new THREE.Line(patchCord.clone(), new THREE.LineBasicMaterial({
        color: 0xff0000,
        opacity: 1
    }));
    curve.mesh.castShadow = true;
    splines.uniform = curve;
    curve = new THREE.CatmullRomCurve3(positions);
    curve.curveType = 'centripetal';
    curve.mesh = new THREE.Line(patchCord.clone(), new THREE.LineBasicMaterial({
        color: 0x00ff00,
        opacity: 1
    }));
    curve.mesh.castShadow = true;
    splines.centripetal = curve;
    curve = new THREE.CatmullRomCurve3(positions);
    curve.curveType = 'chordal';
    curve.mesh = new THREE.Line(patchCord.clone(), new THREE.LineBasicMaterial({
        color: 0x0000ff,
        opacity: 1
    }));
    curve.mesh.castShadow = true;
    splines.chordal = curve;
    for (let k in splines) {
        let spline = splines[k];
        scene.add(spline.mesh);
    }
    updateSplineOutline()

  
  //Font 
  let fontLoader = new THREE.FontLoader;
  let fontFile = 'js/three-r102/examples/fonts/helvetiker_regular.typeface.json';

  fontLoader.load(fontFile, function ( font ) {

    let color = 0x00ff00;
    let text, xMid;
    let material = new THREE.MeshBasicMaterial({
              color: color,
              transparent: true,
              opacity: 0.4,
              side: THREE.DoubleSide
    });

    let message = "Text!";

    let shapes = font.generateShapes( message, .5 );
    let shapeGeometry = new THREE.ShapeBufferGeometry( shapes );
    shapeGeometry.computeBoundingBox();

    xMid =  -0.1 *( shapeGeometry.boundingBox.max.x - shapeGeometry.boundingBox.min.x );
    shapeGeometry.translate( xMid, 0, 0 );

    text = new THREE.Mesh( shapeGeometry, material );
    text.position.z = 0;
    text.rotation.y = 180;
     
    scene.add( text );
  });

}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function onSelectStart(event) {
    let controller = event.target;
    let intersections = getIntersections(controller);
    if (intersections.length > 0) {
        let intersection = intersections[0];
        tempMatrix.getInverse(controller.matrixWorld);
        let object = intersection.object;
        object.matrix.premultiply(tempMatrix);
        object.matrix.decompose(object.position, object.quaternion, object.scale);
        //object.material.emissive.b = 1;
        controller.add(object); //removes from previous parent
        controller.userData.selected = object;
    }
}

function onSelectEnd(event) {
    let controller = event.target;
    if (controller.userData.selected !== undefined) {
        let object = controller.userData.selected;
        object.matrix.premultiply(controller.matrixWorld);
        object.matrix.decompose(object.position, object.quaternion, object.scale);
        //object.material.emissive.b = 0;
        group.add(object);
        controller.userData.selected = undefined;
        //updateSplineOutline();

    }
}

function getIntersections(controller) {
    tempMatrix.identity().extractRotation(controller.matrixWorld);
    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
    return raycaster.intersectObjects(group.children);
}

function intersectObjects(controller) {
    // Do not highlight when already selected
    if (controller.userData.selected !== undefined) return;
    let line = controller.getObjectByName("line");
    let intersections = getIntersections(controller);
    if (intersections.length > 0) {
        let intersection = intersections[0];
        let object = intersection.object;
        object.material.emissive.r = 1;
        intersected.push(object);
        line.scale.z = intersection.distance;
    } else {
        line.scale.z = 1;
    }
}

function cleanIntersected() {
    while (intersected.length) {
        let object = intersected.pop();
        object.material.emissive.r = 0;
    }
}

function addSplineObject(position, amount) {
  //Colours the spline points based on if its moveable (Green) or unmoveable (Red)
    if (amount == 0 || amount == splinePointsLength - 1) {
        var material = new THREE.MeshLambertMaterial({
            color: 0x00ff00
        });
    } else {
        var material = new THREE.MeshLambertMaterial({
            color: 0xff0000
        });
    }
    let object = new THREE.Mesh(geometry2, material);
    if (position) {
        object.position.copy(position);
    } else {
        object.position.x = Math.random() * 10 - 5;
        object.position.y = Math.random() * 6;
        object.position.z = Math.random() * 8 - 4;
    }
    object.castShadow = true;
    object.receiveShadow = true;
    if (amount == 0 || amount == splinePointsLength - 1) {
        group.add(object);
    } else {
        scene.add(object);
    }

    splineHelperObjects.push(object);
    return object;
}

function updateSplineOutline() {
    
    for (let k in splines) {
        // todo: this should be spline.positions
        for (let i in positions) {
            //console.log(p)
            splineHelperObjects[i].getWorldPosition(positions[i])
        }
        let spline = splines[k];
        let splineMesh = spline.mesh;
        let position = splineMesh.geometry.attributes.position;
        for (let i = 0; i < ARC_SEGMENTS; i++) {
            let t = i / (ARC_SEGMENTS - 1);
            spline.getPoint(t, point);
            if (i==0) console.log(point)
            position.setXYZ(i, point.x, point.y, point.z);
        }
        position.needsUpdate = true;
    }
}

function load(new_positions) {
    /** This code can be used to add more points to an existing spline or remove from an existing spline
      * for our purposes this seems useless because all the "patch" cables will be always 4 points
      */
  /*
    //Add Point
    while (new_positions.length > positions.length) {
        splinePointsLength++;
        positions.push(addSplineObject().position);
        updateSplineOutline();
    }
     //Remove Point
    while (new_positions.length < positions.length) {
        if (splinePointsLength <= 4) {
            return;
        }
        splinePointsLength--;
        positions.pop();
        scene.remove(splineHelperObjects.pop());
        updateSplineOutline();
    }*/
  
    // Loops through the passed in Vector3's and adds them to the position paramater
    for (let i = 0; i < positions.length; i++) {
        positions[i].copy(new_positions[i]);
    }
    updateSplineOutline();
}

function animate() {
    renderer.setAnimationLoop(render);
}


function render() {
    //Spline
    //updateSplineOutline();
    splines.uniform.mesh.visible = params.uniform;
    splines.centripetal.mesh.visible = params.centripetal;
    splines.chordal.mesh.visible = params.chordal;

    // make sure all objects' matrices are up to date (TODO might not be needed?)
    scene.updateMatrixWorld();

    let p = new THREE.Vector3();
    
    log.textContent = JSON.stringify(p)
    if (controller1.userData.selected !== undefined) {
        
        updateSplineOutline();
    }

    // if (controller1.userData.selected !== undefined) {
    //     let object = controller1.userData.selected;
    //     let object2 = function() {
    //         object.matrix.premultiply(controller1.matrixWorld);
    //         object.matrix.decompose(object.position, object.quaternion, object.scale);
    //     }
    //     /*let temp = object;
    //     object = object2;
    //     object2 = temp;*/
    //     //console.log("Test");
    //     updateSplineOutline();
    // }

    // if (controller2.userData.selected !== undefined) {
    //     let object = controller2.userData.selected;
    //     let object2 = function() {
    //         object.matrix.premultiply(controller2.matrixWorld);
    //         object.matrix.decompose(object.position, object.quaternion, object.scale);
    //     }

    //     let temp = object;
    //     object = object2;
    //     object2 = temp;

    //     updateSplineOutline();
    //   }

    //Objects
    cleanIntersected();
    intersectObjects(controller1);
    intersectObjects(controller2);
    renderer.render(scene, camera);

}
</script>
</body>
</html>